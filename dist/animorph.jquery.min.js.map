{"version":3,"file":null,"sources":["../src/utils/dom-manipulation.js","../src/utils/animation.js","../src/vanilla.js","../src/jquery.js"],"sourcesContent":["/**\n * Removes the given element from it's parent\n *\n * @param  {HTMLElement} node The node to remove\n */\nexport function detachNode (node) {\n  // Detach from dom before any classes are added\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\n\n/**\n * Adds the given element as the first child of the given parent\n *\n * @param  {HTMLElement} node The node to remove\n * @param  {HTMLElement} targetContainer The new parent\n */\nexport function prependNode (node, targetContainer) {\n  if (targetContainer.firstChild) {\n    targetContainer.insertBefore(node, targetContainer.firstChild);\n  } else {\n    targetContainer.appendChild(node);\n  }\n}\n\n/**\n * Clones a given Node an all its content\n * Needed as IE9 does not support node.clone(true)\n *\n * @param  {HTMLElement} node The node to clone\n * @returns  {HTMLElement}\n */\nexport function cloneNode (node) {\n  const clone = node.cloneNode(false);\n  clone.innerHTML = node.innerHTML;\n  return clone;\n}\n\n/**\n * Shorthand to attach a element to the dom\n *\n * @param  {HTMLElement} node The element which should be added\n * @param  {HTMLElement} target The reference element/parent\n * @param  {String} domOperation The dom operation name\n */\nexport function attachNode (node, target, domOperation) {\n  switch (domOperation) {\n    case 'appendTo':\n      target.appendChild(node);\n      break;\n    case 'prependTo':\n      prependNode(node, target);\n      break;\n    case 'insertAfter':\n      insertAfter(node, target);\n      break;\n    default:\n      throw new Error('Invalid dom operation');\n  }\n}\n\n/**\n * Disables all transitions for the given node\n *\n * @param  {HTMLElement} node The element\n */\nexport function disableTransitions (node) {\n  node.style.transition = 'none';\n}\n\n/**\n * Reverts disableTransitions\n *\n * @param  {HTMLElement} node The element\n */\nexport function enableTransitions (node) {\n  node.style.transition = '';\n}\n\n/**\n * Returns the absolute position of the node to the document\n *\n * @param  {HTMLElement} node The element to measure\n * @return {{left: {Number}, top: {Number} }\n */\nexport function getElementPosition (node) {\n  if (node === document.body) {\n    return { left: 0, top: 0 };\n  }\n  // Support: IE <=11 only\n  // Running getBoundingClientRect on a\n  // disconnected node in IE throws an error\n  if (!node.getClientRects().length) {\n    return { top: 0, left: 0 };\n  }\n  const rect = node.getBoundingClientRect();\n  if (rect.width || rect.height) {\n    const docElem = document.documentElement;\n    return {\n      top: rect.top + window.pageYOffset - docElem.clientTop,\n      left: rect.left + window.pageXOffset - docElem.clientLeft\n    };\n  }\n\n  // Return zeros for disconnected and hidden elements (gh-2310)\n  return rect;\n}\n\n/**\n * Returns a Promise which is resolved after delay of (transition duration + transition delay).\n *\n * This is a replacement for onTransitionEnd as we can't guarantee that an animation started\n * and would wait forever.\n *\n * @param  {HTMLElement} node The element with a css-transition\n * @return {Promise}\n */\nexport function waitUntilTransitionEnd (node) {\n  const durations = getTransitionDuration(node);\n  const delays = getTransitionDelay(node);\n  const entireAnimationTimes = durations.map((duration, i) => duration + delays[i]);\n  const longestDuration = Math.max(...entireAnimationTimes);\n  return new Promise((resolve) => {\n    setTimeout(() => resolve(node), longestDuration);\n  });\n}\n\n/**\n * Extract an array of all classNames of the given DOM or SVG node\n *\n * @param  {HTMLElement} element The element\n * @return {String[]} Classes\n */\nexport function getClassNames (element) {\n  const className = element.getAttribute && element.getAttribute('class') || '';\n  return className === '' ? [] : className.split(' ');\n}\n\n/**\n * Replacement for DomTokenList\n *\n * IE 9 doesn't support element classList and IE 11 doesn't support classList for SVG elements\n * see also https://developer.mozilla.org/en/docs/Web/API/Element/classList\n *\n * Usage:\n * toggleClass(div, 'demo'); // Toggles the class `demo`\n * toggleClass(div, 'demo', true); // Adds the class `demo`\n * toggleClass(div, 'demo', false); // removes the class `demo`\n *\n * @param  {HTMLElement} element The target node\n * @param  {String} className The class name to toggle\n * @param  {boolean} force Optional - true will allways add - false will alawys remove\n */\nexport function toggleClass (element, className, force) {\n  const classNames = getClassNames(element);\n  const idx = classNames.indexOf(className);\n  const hasClass = idx !== -1;\n  const shouldHaveClass = force !== undefined ? force : !hasClass;\n  // Break if classes are already set/removed\n  if (shouldHaveClass === hasClass) {\n    return;\n  }\n  // Remove class\n  if (!shouldHaveClass) {\n    classNames.splice(idx, 1);\n  }\n  // Add class\n  if (shouldHaveClass) {\n    classNames.push(className);\n  }\n  element.setAttribute('class', classNames.join(' '));\n}\n\n/**\n * Remove the given class name from the element\n * @param  {HTMLElement} element The DOM Node\n * @param  {String} className The class name\n */\nexport function removeClass (element, className) {\n  if (className === undefined) {\n    throw new Error('Class name is required');\n  }\n  toggleClass(element, className, false);\n}\n\n/**\n * Adds the given class name from the element\n * @param  {HTMLElement} element The DOM Node\n * @param  {String} className The class name\n */\nexport function addClass (element, className) {\n  if (className === undefined) {\n    throw new Error('Class name is required');\n  }\n  toggleClass(element, className, true);\n}\n\n/**\n * Turns \"2s\" or \"2000ms\" into 2000\n * @param  {string} timeString A unit postfixed time string\n * @return {number} milliseconds\n */\nfunction stringToMilliSeconds (timeString) {\n  const timeUnits = {\n    s: 1000,\n    ms: 1\n  };\n  const parsedTime = /([.\\d]+)\\s*(\\D+)/.exec(timeString);\n  return parsedTime ? parseFloat(parsedTime[1], 10) * timeUnits[parsedTime[2]] : 0;\n}\n\n/**\n * Returns the duration of an elements transition\n * @param  {HTMLElement} node The element to measure\n * @return {Number[]} time in milliseconds\n */\nfunction getTransitionDuration (node) {\n  return (window.getComputedStyle(node).transitionDuration || '')\n    .split(',')\n    .map((delay) => stringToMilliSeconds(delay));\n}\n\n/**\n * Returns the delay of an elements transition\n * @param  {HTMLElement} node The element to measure\n * @return {Number[]} time in milliseconds\n */\nexport function getTransitionDelay (node) {\n  return (window.getComputedStyle(node).transitionDelay || '')\n    .split(',')\n    .map((delay) => stringToMilliSeconds(delay));\n}\n\n/**\n * Force a browser repaint to apply all current styles\n *\n * @param node\n */\nexport function forceReflow (node) {\n  return new Promise((resolve) => {\n    resolve(node.offsetHeight);\n  });\n}\n\n/**\n * Checks if node is a dom element\n * @param node\n * @returns {*}\n */\nexport function isDomElement (node) {\n  // For all modern browser\n  if (window.HTMLElement) {\n    return node instanceof window.HTMLElement;\n  }\n  // For IE9 <3\n  return node && typeof node === 'object' && node.nodeType === 1 && node.nodeName;\n}\n\n/**\n * Inserts a new node after a desired reference node.\n * @param referenceNode\n * @param newNode\n * @returns {Node}\n */\nexport function insertAfter (referenceNode, newNode) {\n  // For all modern browser and Firefox version 48 and higher\n  if (referenceNode.insertAdjacentElement) {\n    return referenceNode.insertAdjacentElement('afterend', newNode);\n  }\n  // For Firefox version 48 and lower\n  // If referenceNode is the last child within its parent element, that's fine, because referenceNode.nextSibling\n  // will be null and insertBefore handles that case by adding to the end of the parent\n  return referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);\n}\n","import {\n  addClass,\n  removeClass,\n  getClassNames,\n  getElementPosition,\n  detachNode,\n  attachNode,\n  cloneNode,\n  waitUntilTransitionEnd,\n  enableTransitions,\n  disableTransitions,\n  getTransitionDelay,\n  forceReflow,\n  insertAfter\n} from './dom-manipulation';\n\n/**\n * An animation which adds the `enter` classes and adds the element to the dom\n *\n * @param  {String} namespace       The animation class namespace e.g. 'am'\n * @param  {String[]} addClasses    Classes which will be added once the animation starts\n * @param  {String[]} removeClasses Classes which will be removed once the animation starts\n * @param  {HTMLElement} element    The element\n * @param  {HTMLElement} target     Optional - needed as reference for the new DOM position\n * @param  {\"appendTo\"|\"prependTo\"|\"insertAfter\"} operation  Dom operation\n * @return {Promise} A promise which will be resolved once the animation is complete\n */\nexport function enterAnimation ({\n  namespace,\n  addClasses,\n  removeClasses,\n  element,\n  target,\n  operation,\n  animationIndex\n}) {\n  if (target) {\n    attachNode(element, target, operation);\n  }\n  return animation({\n    namespace,\n    element,\n    addClasses,\n    removeClasses,\n    animationIndex,\n    animationName: 'enter'\n  });\n}\n\n/**\n * An animation which adds the `leave` classes and adds the element to the dom\n *\n * @param  {String} namespace     The animation class namespace e.g. 'am'\n * @param  {HTMLElement} element  [description]\n * @param  {String[]} addClasses  Classes which will be added once the animation starts\n * @param  {String[]} removeClasses Classes which will be removed once the animation starts\n * @return {Promise} A promise which will be resolved once the animation is complete\n */\nexport function leaveAnimation ({\n  namespace,\n  element,\n  addClasses,\n  removeClasses,\n  animationIndex\n}) {\n  return animation({\n    namespace,\n    element,\n    addClasses,\n    removeClasses,\n    animationIndex,\n    animationName: 'leave'\n  });\n}\n\n/**\n * An animation which morphs an element from its old position to its new position\n *\n * @param  {String} namespace        The animation class namespace e.g. 'am'\n * @param  {String[]} addClasses     Classes which will be added once the animation starts\n * @param  {String[]} removeClasses  Classes which will be removed once the animation starts\n * @param  {HTMLElement} element     The element to animate\n * @param  {HTMLElement} target      The reference target to attach the element into the DOM\n * @param  {HTMLElement} operation   The attach method\n * @param  {HTMLElement} morphParent The wrapper for the move clone\n * @return {Promise} A promise which will be resolved once the animation is complete\n */\nexport function morphAnimation ({\n  namespace,\n  addClasses,\n  removeClasses,\n  element,\n  target,\n  operation,\n  morphParent,\n  animationIndex\n}) {\n  if (element instanceof window.HTMLElement === false) {\n    throw new Error('target is required');\n  }\n  // Create clones which are needed for the morph effect\n  const leavePlaceholder = _createLeavePlaceholder(element);\n  const movePlaceholder = _createMovePlaceholder(element, morphParent);\n  // Add final classes for the enter element to determine the correct target position\n  addClasses.forEach((className) => addClass(element, className));\n  removeClasses.forEach((className) => removeClass(element, className));\n  // Wait for all animations to finish\n  return Promise.all([\n    enterAnimation({\n      namespace,\n      addClasses: [],\n      removeClasses: [],\n      element,\n      target,\n      operation,\n      animationIndex\n    }),\n    moveAnimation({\n      namespace,\n      addClasses,\n      removeClasses,\n      element: movePlaceholder,\n      morphParent,\n      target: element,\n      animationIndex\n    }),\n    removeAnimation({\n      namespace,\n      addClasses: [],\n      removeClasses: [],\n      element: leavePlaceholder,\n      animationIndex\n    })\n  ]).then(() => {\n    detachNode(movePlaceholder);\n  });\n}\n\n/**\n * This animation will add the leave classes and remove the element form the\n * DOM once the animation is complete\n *\n * @param  {Object} options All leaveAnimation options\n * @return {Promise}\n */\nexport function removeAnimation (options) {\n  return leaveAnimation(options).then(() => detachNode(options.element));\n}\n\n/**\n * Moves the given element to the target Position\n *\n * @param  {String} namespace     The animation class namespace e.g. 'am'\n * @param  {String[]} addClasses  Classes which will be added once the animation starts\n * @param  {String[]} removeClasses Classes which will be removed once the animation starts\n * @param  {HTMLElement} element  [description]\n * @param  {[type]} target        [description]\n * @param  {[type]} morphParent   [description]\n * @return {Promise} A promise which will be resolved once the animation is complete\n */\nfunction moveAnimation ({\n  namespace,\n  addClasses,\n  removeClasses,\n  element,\n  target,\n  morphParent,\n  animationIndex\n}) {\n  const targetPosition = getElementPosition(target);\n  const parentPosition = getElementPosition(morphParent);\n  const targetStyles = window.getComputedStyle(target);\n\n  const top = targetPosition.top - parentPosition.top - parseFloat(targetStyles.marginTop);\n  const left = targetPosition.left - parentPosition.left - parseFloat(targetStyles.marginLeft);\n\n  return animation({\n    namespace,\n    element,\n    addClasses,\n    removeClasses,\n    animationIndex,\n    animationName: 'move',\n    onAnimationStart: () => {\n      element.style.position = 'absolute';\n      element.style.left = `${left}px`;\n      element.style.top = `${top}px`;\n    }\n  });\n}\n\n/**\n * Helper function which does the entire animation from start to cleanup\n *\n * @param  {String} namespace       The animation class namespace e.g. 'am'\n * @param  {String[]} addClasses    Classes which will be added once the animation starts\n * @param  {String[]} removeClasses Classes which will be removed once the animation starts\n * @param  {HTMLElement} element    The Element which to animate\n * @param  {HTMLElement} morphParent   [description]\n * @param  {function} [onAnimationStart] [description]\n * @return {Promise} A promise which will be resolved once the animation is complete\n */\nfunction animation ({\n  namespace,\n  addClasses,\n  removeClasses,\n  element,\n  animationName,\n  animationIndex,\n  onAnimationStart = () => {}\n}) {\n  return _startAnimation({\n    namespace,\n    element,\n    addClasses,\n    removeClasses,\n    animationName,\n    animationIndex\n  })\n  .then(onAnimationStart)\n  .then(() => waitUntilTransitionEnd(element))\n  .then(() => _removeAnimationClasses({\n    namespace,\n    element,\n    animationName\n  }));\n}\n\nfunction _createLeavePlaceholder (node) {\n  const clone = cloneNode(node);\n  insertAfter(node, clone);\n  return clone;\n}\n\n/**\n * Create a clone and place it absolute directly above the given node\n *\n * @param  {HTMLElement} node        The node to clone\n * @param  {HTMLElement} morphParent The parent for the clone\n * @return {HTMLElement} clone\n */\nfunction _createMovePlaceholder (node, morphParent) {\n  const clone = cloneNode(node);\n  const elementPosition = getElementPosition(node);\n  const parentPosition = getElementPosition(morphParent);\n  const nodeStyles = window.getComputedStyle(node);\n  const top = elementPosition.top - parentPosition.top - parseFloat(nodeStyles.marginTop);\n  const left = elementPosition.left - parentPosition.left - parseFloat(nodeStyles.marginLeft);\n\n  clone.style.position = 'absolute';\n  clone.style.left = `${left}px`;\n  clone.style.top = `${top}px`;\n  morphParent.appendChild(clone);\n  return clone;\n}\n\nfunction _startAnimation ({\n  namespace,\n  element,\n  addClasses,\n  removeClasses,\n  animationIndex,\n  animationName = 'enter'\n}) {\n  const cacheKey = _composeCacheKey(element, namespace, animationName);\n  const staggeringDuration = animationIndex === 0 ? 0 : _getStaggeringFromCache({element, animationIndex, animationName, namespace}, cacheKey);\n\n  disableTransitions(element);\n  addClass(element, `${namespace}-${animationName}-prepare`);\n  addClass(element, `${namespace}-${animationName}`);\n  addClass(element, `${namespace}-animate`);\n\n  return new Promise((resolve) => {\n    setTimeout(resolve, staggeringDuration);\n  }).then(() => forceReflow(element).then(() => {\n    forceReflow(element);\n    removeClass(element, `${namespace}-${animationName}-prepare`);\n    addClass(element, `${namespace}-${animationName}-active`);\n    addClasses.forEach((className) => addClass(element, className));\n    removeClasses.forEach((className) => removeClass(element, className));\n    enableTransitions(element);\n  }));\n}\n\n/**\n * Returns a cache-key based on the class-names\n * @param {HTMLElement} node The HTML-node to receive the classes from\n * @param {string} namespace The namespace on which to append the animationName\n * @param {string} animationName The name of the animation (e.g. enter / leave)\n * @return {string} The key composed of the class-names of the node\n */\nfunction _composeCacheKey (node, namespace, animationName) {\n  var classNames = getClassNames(node);\n  classNames.push(`${namespace}-${animationName}`);\n  classNames.sort();\n  return classNames.join(' ');\n}\n\nfunction _removeAnimationClasses ({element, animationName, namespace}) {\n  disableTransitions(element);\n  return forceReflow(element)\n  .then(() => {\n    removeClass(element, `${namespace}-animate`);\n    removeClass(element, `${namespace}-${animationName}`);\n    removeClass(element, `${namespace}-${animationName}-active`);\n    enableTransitions(element);\n  });\n}\n\n/**\n * Adds the stagger classes measure the stagger duration and removes\n * the classes again.\n */\nfunction _getStaggering ({element, animationName, namespace}) {\n  const delayWithoutStagger = getTransitionDelay(element);\n  addClass(element, `${namespace}-stagger`);\n  addClass(element, `${namespace}-${animationName}-stagger`);\n  const delayWithStagger = getTransitionDelay(element);\n  removeClass(element, `${namespace}-stagger`);\n  removeClass(element, `${namespace}-${animationName}-stagger`);\n  // If there is no difference with or without the stagger class\n  // asume that there is no staggering\n  return delayWithoutStagger[0] === delayWithStagger[0] ? 0 : delayWithStagger[0];\n}\n\nconst staggeringCache = {};\n/**\n * Returns the staggering duration from cache\n * The value is calculated if no duration is cache\n */\nfunction _getStaggeringFromCache ({element, animationIndex, animationName, namespace}, cacheKey) {\n  if (!staggeringCache[cacheKey]) {\n    staggeringCache[cacheKey] = _getStaggering({element, animationIndex, animationName, namespace});\n  }\n  return staggeringCache[cacheKey] * animationIndex;\n}\n","import {\n  morphAnimation,\n  enterAnimation,\n  leaveAnimation,\n  removeAnimation\n} from './utils/animation';\n\nimport {\n  isDomElement\n} from './utils/dom-manipulation';\n\n// Mapping of dom operation to animation\nconst operations = {\n  appendTo: morphAnimation,\n  prependTo: morphAnimation,\n  insertBefore: morphAnimation,\n  insertAfter: morphAnimation,\n  remove: removeAnimation,\n  enter: enterAnimation,\n  leave: leaveAnimation\n};\n\nexport function animorph (element, {\n  namespace = 'am',\n  addClasses = [],\n  removeClasses = [],\n  target,\n  operation = 'appendTo',\n  morphParent = document.body\n}) {\n  let animation = operations[operation];\n  if (!animation) {\n    throw new Error(`Invalid operation '${operation}'`);\n  }\n\n  if (typeof addClasses === 'string') {\n    addClasses = addClasses.split(/\\s*(?:\\s|,)\\s*/);\n  }\n\n  if (typeof removeClasses === 'string') {\n    removeClasses = removeClasses.split(/\\s*(?:\\s|,)\\s*/);\n  }\n  // Turn element from a single element or a node list or an array to an array:\n  const elements = isDomElement(element) ? [element] : Array.prototype.slice.call(element);\n  return Promise.all(elements.map((element, animationIndex) => {\n    if (!isDomElement(element)) {\n      throw new Error('Element is required');\n    }\n    // If we can't use a move animation fallback to an enter animation\n    if (animation === morphAnimation && !morphParent.contains(element)) {\n      animation = enterAnimation;\n    }\n    return animation({\n      animationIndex,\n      namespace,\n      addClasses,\n      removeClasses,\n      element,\n      target,\n      operation,\n      morphParent\n    });\n  }));\n}\n\n/**\n * Inserts the given element as last child to the given target.\n * If the element was in the dom before it is animated\n * from the old position to the new position.\n *\n * @jsfiddle https://jsfiddle.net/aoz5y2n7/3/embedded/\n * @param  {HTMLElement} element   The element to animate\n * @param  {Object} [options]      Animorph options like namespace @see animorph\n * @return {Promise}               Promise of the animation\n */\nexport function appendTo (element, target, options = {}) {\n  return animorph(element, {\n    target,\n    ...options\n  });\n}\n\n/**\n * Inserts the given element as first child to the given target.\n * If the element was in the dom before it is animated\n * from the old position to the new position.\n *\n * @param  {HTMLElement} element   The element to animate\n * @param  {Object} [options]      Animorph options like namespace @see animorph\n * @return {Promise}               Promise of the animation\n */\nexport function prependTo (element, target, options = {}) {\n  return animorph(element, {\n    target,\n    operation: 'prependTo',\n    ...options\n  });\n}\n\n/**\n * Animate the given element and removes it from the dom after\n * the animation is complete\n *\n * @param  {HTMLElement} element   The element to animate\n * @param  {Object} [options]      Animorph options like namespace @see animorph\n * @return {Promise}               Promise of the animation\n */\nexport function remove (element, options = {}) {\n  return animorph(element, {\n    operation: 'remove',\n    ...options\n  });\n}\n\n/**\n * Adds classes for an enter animation\n *\n * Flow:\n *\n * 1. Changes the classes (without animation)\n *    + Add: `${namespace}-enter-prepare`\n *    + Add: `${namespace}-enter`\n *    + Add: `${namespace}-animate`\n * 2. Changes the classes (with animation)\n *    + Add: `${namespace}-enter-active`\n *    + Remove: `${namespace}-enter-prepare`\n * 4. Waits for the animation to end\n * 5. Changes the classes (without animation)\n *    + Remove: `${namespace}-enter-active`\n *    + Remove: `${namespace}-enter`\n *    + Remove: `${namespace}-animate`\n * 6. Fullfills the promise\n *\n * @param  {HTMLElement} element   The element to animate\n * @param  {Object} [options]      Animorph options like namespace @see animorph\n * @return {Promise}               Promise of the animation\n */\nexport function enter (element, options = {}) {\n  return animorph(element, {\n    operation: 'enter',\n    ...options\n  });\n}\n\n/**\n * Adds classes for a leave animation\n *\n * Flow:\n *\n * 1. Changes the classes (without animation)\n *    + Add: `${namespace}-leave-prepare`\n *    + Add: `${namespace}-leave`\n *    + Add: `${namespace}-animate`\n * 2. Changes the classes (with animation)\n *    + Add: `${namespace}-leave-active`\n *    + Remove: `${namespace}-leave-prepare`\n * 4. Waits for the animation to end\n * 5. Changes the classes (without animation)\n *    + Remove: `${namespace}-leave-active`\n *    + Remove: `${namespace}-leave`\n *    + Remove: `${namespace}-animate`\n * 6. Fullfills the promise\n *\n * @param  {HTMLElement} element   The element to animate\n * @param  {Object} [options]      Animorph options like namespace @see animorph\n * @return {Promise}               Promise of the animation\n */\nexport function leave (element, options = {}) {\n  return animorph(element, {\n    operation: 'leave',\n    ...options\n  });\n}\n\n/**\n * Inserts the given element to the dom after the given target.\n * If the element was in the dom before it is animated\n * from the old position to the new position.\n *\n * @param  {HTMLElement} element   The element to animate\n * @param  {Object} [options]      Animorph options like namespace @see animorph\n * @return {Promise}               Promise of the animation\n */\nexport function insertAfter (element, target, options = {}) {\n  return animorph(element, {\n    target: target,\n    operation: 'insertAfter',\n    ...options\n  });\n}\n\n/**\n * Adds and removes css-classes from the given element.\n *\n * Flow:\n *\n * 1. Changes the classes (without animation)\n *    + Add: `${namespace}-${transitionName}-prepare`\n *    + Add: `${namespace}-${transitionName}`\n *    + Add: `${namespace}-animate`\n * 2. Changes the classes (with animation)\n *    + Add: `${namespace}-${transitionName}-active`\n *    + Add: custom class names (optional)\n *    + Remove: `${namespace}-${transitionName}-prepare`\n *    + Remove: custom class names (optional)\n * 4. Waits for the animation to end\n * 5. Changes the classes (without animation)\n *    + Remove: `${namespace}-${transitionName}-active`\n *    + Remove: `${namespace}-${transitionName}`\n *    + Remove: `${namespace}-animate`\n * 6. Fullfills the promise\n *\n * @param  {HTMLElement} element        The element to animate\n * @param  {String[]} classNamesBefore  Custom classes to be removed\n * @param  {String[]} classNamesAfter   Custom classes to be added\n * @param  {String} [\"enter\"|\"leave\"]   Transition name: \"enter\"|\"leave\"\n * @param  {Object} [options]           Animorph options like namespace @see animorph\n * @return {Promise}                    Promise of the animation\n */\nexport function replaceClasses (element, classNamesBefore, classNamesAfter, transitionName = 'enter', options = {}) {\n  return animorph(element, {\n    addClasses: classNamesAfter,\n    removeClasses: classNamesBefore,\n    operation: transitionName,\n    ...options\n  });\n}\n","import {appendTo, prependTo, remove, leave, insertAfter, replaceClasses} from './vanilla.js';\nimport $ from 'jquery';\n\n/**\n * Append the current element to the target\n * This will start a move animation if the current element is already in the dom.\n *\n * @param  {JQuery|HTMLElement|String} target\n * @param  {object} options animorph options like namespace\n * @return {Promise}        Animation Promise\n */\n$.fn.amAppendTo = function (target, options) {\n  return appendTo(this.toArray(), $(target)[0], options);\n};\n\n/**\n * Prepend the current element to the target\n * This will start a move animation if the current element is already in the dom.\n *\n * @param  {JQuery|HTMLElement|String} target\n * @param  {object} options animorph options like namespace\n * @return {Promise}        Animation Promise\n */\n$.fn.amPrependTo = function (target, options) {\n  return prependTo(this.toArray(), $(target)[0], options);\n};\n\n/**\n * Run a leave animation and remove the current element from the dom after it finished\n *\n * @param  {object} options animorph options like namespace\n * @return {Promise}        Animation Promise\n */\n$.fn.amRemove = function (options) {\n  return remove(this.toArray(), options);\n};\n\n/**\n * Run a leave animation and remove the current element from the dom after it finished\n *\n * @param  {object} options animorph options like namespace\n * @return {Promise}        Animation Promise\n */\n$.fn.amLeave = function (options) {\n  return leave(this.toArray(), options);\n};\n\n/**\n * Inserts the current element after the target\n * This will start a move animation if the current element is already in the dom.\n *\n * @param  {JQuery|HTMLElement|String} target\n * @param  {object}     options animorph options like namespace\n * @return {Promise}    Animation Promise\n */\n$.fn.amInsertAfter = function (target, options) {\n  return insertAfter(this.toArray(), $(target)[0], options);\n};\n\n/**\n * Adds and removes css-classes from the given element.\n *\n * @param  {String|String[]} classNamesBefore class names to remove\n * @param  {String|String[]} classNamesAfter  class names to add\n * @param  {String}  Transition name `\"enter\"|\"leave\"`\n * @param  {object} options animorph options like namespace\n * @return {Promise}    Animation Promise\n */\n$.fn.amReplaceClasses = function (classNamesBefore, classNamesAfter, transitionName, options) {\n  return replaceClasses(this.toArray(), classNamesBefore, classNamesAfter, transitionName, options);\n};\n\nexport * from './vanilla.js';\n"],"names":["detachNode","node","parentNode","removeChild","prependNode","targetContainer","firstChild","insertBefore","appendChild","cloneNode","clone","innerHTML","attachNode","target","domOperation","Error","disableTransitions","style","transition","enableTransitions","getElementPosition","document","body","left","top","getClientRects","length","rect","getBoundingClientRect","width","height","docElem","documentElement","window","pageYOffset","clientTop","pageXOffset","clientLeft","waitUntilTransitionEnd","durations","getTransitionDuration","delays","getTransitionDelay","entireAnimationTimes","map","duration","i","longestDuration","Math","max","Promise","resolve","getClassNames","element","className","getAttribute","split","toggleClass","force","classNames","idx","indexOf","hasClass","shouldHaveClass","undefined","splice","push","setAttribute","join","removeClass","addClass","stringToMilliSeconds","timeString","timeUnits","parsedTime","exec","parseFloat","getComputedStyle","transitionDuration","delay","transitionDelay","forceReflow","offsetHeight","isDomElement","HTMLElement","nodeType","nodeName","insertAfter","referenceNode","newNode","insertAdjacentElement","nextSibling","enterAnimation","namespace","addClasses","removeClasses","operation","animationIndex","animation","leaveAnimation","morphAnimation","morphParent","leavePlaceholder","_createLeavePlaceholder","movePlaceholder","_createMovePlaceholder","forEach","all","moveAnimation","removeAnimation","then","options","targetPosition","parentPosition","targetStyles","marginTop","marginLeft","position","animationName","onAnimationStart","_startAnimation","_removeAnimationClasses","elementPosition","nodeStyles","cacheKey","_composeCacheKey","staggeringDuration","_getStaggeringFromCache","sort","_getStaggering","delayWithoutStagger","delayWithStagger","staggeringCache","animorph","operations","elements","Array","prototype","slice","call","contains","appendTo","prependTo","remove","enter","leave","replaceClasses","classNamesBefore","classNamesAfter","transitionName","$","fn","amAppendTo","this","toArray","amPrependTo","amRemove","amLeave","amInsertAfter","amReplaceClasses"],"mappings":"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"}