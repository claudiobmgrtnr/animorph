{"version":3,"file":null,"sources":["../src/utils/dom-manipulation.js","../src/utils/request-animation-frame.js","../src/utils/animation.js","../src/vanilla.js","../src/jquery.js"],"sourcesContent":["/**\n * Removes the given element from it's parent\n *\n * @param  {HTMLElement} node The node to remove\n */\nexport function detachNode (node) {\n  // Detach from dom before any classes are added\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\n\n/**\n * Adds the given element as the first child of the given parent\n *\n * @param  {HTMLElement} node The node to remove\n * @param  {HTMLElement} targetContainer The new parent\n */\nexport function prependNode (node, targetContainer) {\n  if (targetContainer.firstChild) {\n    targetContainer.insertBefore(node, targetContainer.firstChild);\n  } else {\n    targetContainer.appendChild(node);\n  }\n}\n\n/**\n * Clones a given Node an all its content\n * Needed as IE9 does not support node.clone(true)\n *\n * @param  {HTMLElement} node The node to clone\n * @returns  {HTMLElement}\n */\nexport function cloneNode (node) {\n  const clone = node.cloneNode(false);\n  clone.innerHTML = node.innerHTML;\n  return clone;\n}\n\n/**\n * Shorthand to attach a element to the dom\n *\n * @param  {HTMLElement} node The element which should be added\n * @param  {HTMLElement} target The reference element/parent\n * @param  {String} domOperation The dom operation name\n */\nexport function attachNode (node, target, domOperation) {\n  switch (domOperation) {\n    case 'appendTo':\n      target.appendChild(node);\n      break;\n    case 'prependTo':\n      prependNode(node, target);\n      break;\n    case 'insertAfter':\n      node.insertAdjacentElement('afterend', target);\n      break;\n    default:\n      throw new Error('Invalid dom operation');\n  }\n}\n\n/**\n * Disables all transitions for the given node\n *\n * @param  {HTMLElement} node The element\n */\nexport function disableTransitions (node) {\n  node.style.transition = 'none';\n}\n\n/**\n * Reverts disableTransitions\n *\n * @param  {HTMLElement} node The element\n */\nexport function enableTransitions (node) {\n  node.style.transition = '';\n}\n\n/**\n * Returns the absolute position of the node to the document\n *\n * @param  {HTMLElement} node The element to measure\n * @return {{left: {Number}, top: {Number} }\n */\nexport function getElementPosition (node) {\n  const rect = node.getBoundingClientRect();\n  const offset = {\n    top: rect.top + document.body.scrollTop,\n    left: rect.left + document.body.scrollLeft\n  };\n  return offset;\n}\n\n/**\n * Returns a Promise which is resolved after delay of (transition duration + transition delay).\n *\n * This is a replacement for onTransitionEnd as we can't guarantee that an animation started\n * and would wait forever.\n *\n * @param  {HTMLElement} node The element with a css-transition\n * @return {Promise}\n */\nexport function waitUntilTransitionEnd (node) {\n  const duration = getTransitionDuration(node);\n  return new Promise((resolve) => {\n    setTimeout(() => resolve(node), duration);\n  });\n}\n\n/**\n * Extract an array of all classNames of the given DOM or SVG node\n *\n * @param  {HTMLElement} element The element\n * @return {String[]} Classes\n */\nfunction getClassNames (element) {\n  const className = element.getAttribute && element.getAttribute('class') || '';\n  return className === '' ? [] : className.split(' ');\n}\n\n/**\n * Replacement for DomTokenList\n *\n * IE 9 doesn't support element classList and IE 11 doesn't support classList for SVG elements\n * see also https://developer.mozilla.org/en/docs/Web/API/Element/classList\n *\n * Usage:\n * toggleClass(div, 'demo'); // Toggles the class `demo`\n * toggleClass(div, 'demo', true); // Adds the class `demo`\n * toggleClass(div, 'demo', false); // removes the class `demo`\n *\n * @param  {HTMLElement} element The target node\n * @param  {String} className The class name to toggle\n * @param  {boolean} force Optional - true will allways add - false will alawys remove\n */\nexport function toggleClass (element, className, force) {\n  const classNames = getClassNames(element);\n  const idx = classNames.indexOf(className);\n  const hasClass = idx !== -1;\n  const shouldHaveClass = force !== undefined ? force : !hasClass;\n  // Break if classes are already set/removed\n  if (shouldHaveClass === hasClass) {\n    return;\n  }\n  // Remove class\n  if (!shouldHaveClass) {\n    classNames.splice(idx, 1);\n  }\n  // Add class\n  if (shouldHaveClass) {\n    classNames.push(className);\n  }\n  element.setAttribute('class', classNames.join(' '));\n}\n\n/**\n * Remove the given class name from the element\n * @param  {HTMLElement} element The DOM Node\n * @param  {String} className The class name\n */\nexport function removeClass (element, className) {\n  if (className === undefined) {\n    throw new Error('Class name is required');\n  }\n  toggleClass(element, className, false);\n}\n\n/**\n * Adds the given class name from the element\n * @param  {HTMLElement} element The DOM Node\n * @param  {String} className The class name\n */\nexport function addClass (element, className) {\n  if (className === undefined) {\n    throw new Error('Class name is required');\n  }\n  toggleClass(element, className, true);\n}\n\n/**\n * Turns \"2s\" or \"2000ms\" into 2000\n * @param  {string} timeString A unit postfixed time string\n * @return {number} milliseconds\n */\nfunction stringToMilliSeconds (timeString) {\n  const timeUnits = {\n    s: 1000,\n    ms: 1\n  };\n  const parsedTime = /([\\d\\.]+)\\s*(\\D+)/.exec(timeString);\n  return parsedTime ? parseFloat(parsedTime[1], 10) * timeUnits[parsedTime[2]] : 0;\n}\n\n/**\n * Returns the duration of an elements transition including the transition delay\n * @param  {HTMLElement} node The element to measure\n * @return {Number} time in milliseconds\n */\nexport function getTransitionDuration (node) {\n  const duration = stringToMilliSeconds(window.getComputedStyle(node).transitionDuration);\n  const delay = stringToMilliSeconds(window.getComputedStyle(node).transitionDelay);\n  return duration + delay;\n}\n","const requestAnimationFrame = window.requestAnimationFrame || setTimeout;\n\nexport function requestAnimationFramePromise () {\n  return new Promise((resolve) => requestAnimationFrame(resolve));\n}\n","import { addClass, removeClass, detachNode, attachNode, cloneNode, waitUntilTransitionEnd, enableTransitions, disableTransitions } from './dom-manipulation';\nimport { requestAnimationFramePromise } from './request-animation-frame';\n\n/**\n * An animation which adds the `enter` classes and adds the element to the dom\n *\n * @param  {String} namespace     The animation class namespace e.g. 'am'\n * @param  {String[]} addClasses  Classes which will be added once the animation starts\n * @param  {String[]} removeClasses Classes which will be removed once the animation starts\n * @param  {[type]} element       The element\n * @param  {[type]} target        Optional - needed as reference to add the element into DOM\n * @param  {[type]} operation     Optional - needed to add the element into DOM\n * @return {Promise} A promise which will be resolved once the animation is complete\n */\nexport function enterAnimation ({\n  namespace,\n  addClasses,\n  removeClasses,\n  element,\n  target,\n  operation\n}) {\n  if (target) {\n    attachNode(element, target, operation);\n  }\n  return animation({\n    namespace,\n    element,\n    addClasses,\n    removeClasses,\n    animationName: 'enter'\n  });\n}\n\n/**\n * An animation which adds the `leave` classes and adds the element to the dom\n *\n * @param  {String} namespace     The animation class namespace e.g. 'am'\n * @param  {[type]} element       [description]\n * @param  {String[]} addClasses  Classes which will be added once the animation starts\n * @param  {String[]} removeClasses Classes which will be removed once the animation starts\n * @return {Promise} A promise which will be resolved once the animation is complete\n */\nexport function leaveAnimation ({\n  namespace,\n  element,\n  addClasses,\n  removeClasses\n}) {\n  return animation({\n    namespace,\n    element,\n    addClasses,\n    removeClasses,\n    animationName: 'leave'\n  });\n}\n\n/**\n * An animation which morphs an element from its old position to its new position\n *\n * @param  {String} namespace        The animation class namespace e.g. 'am'\n * @param  {String[]} addClasses     Classes which will be added once the animation starts\n * @param  {String[]} removeClasses  Classes which will be removed once the animation starts\n * @param  {HTMLElement} element     The element to animate\n * @param  {HTMLElement} target      The reference target to attach the element into the DOM\n * @param  {HTMLElement} operation   The attach method\n * @param  {HTMLElement} morphParent The wrapper for the move clone\n * @return {Promise} A promise which will be resolved once the animation is complete\n */\nexport function morphAnimation ({\n  namespace,\n  addClasses,\n  removeClasses,\n  element,\n  target,\n  operation,\n  morphParent\n}) {\n  if (element instanceof window.HTMLElement === false) {\n    throw new Error('target is required');\n  }\n  // Create clones which are needed for the morph effect\n  const leavePlaceholder = _createLeavePlaceholder(element);\n  const movePlaceholder = _createMovePlaceholder(element, morphParent);\n  // Wait for all animations to finish\n  return Promise.all([\n    enterAnimation({\n      namespace,\n      addClasses,\n      removeClasses,\n      element,\n      target,\n      operation\n    }),\n    moveAnimation({\n      namespace,\n      addClasses,\n      removeClasses,\n      element: movePlaceholder,\n      morphParent,\n      target: element\n    }),\n    leaveAnimation({\n      namespace,\n      addClasses: [],\n      removeClasses: [],\n      element: leavePlaceholder\n    })\n  ]).then(() => {\n    detachNode(leavePlaceholder);\n    detachNode(movePlaceholder);\n  });\n}\n\n/**\n * This animation will add the leave classes and remove the element form the\n * DOM once the animation is complete\n *\n * @param  {Object} options All leaveAnimation options\n * @return {Promise}\n */\nexport function removeAnimation (options) {\n  return leaveAnimation(options).then(() => detachNode(options.element));\n}\n\n/**\n * Moves the given element to the target Position\n *\n * @param  {String} namespace     The animation class namespace e.g. 'am'\n * @param  {String[]} addClasses  Classes which will be added once the animation starts\n * @param  {String[]} removeClasses Classes which will be removed once the animation starts\n * @param  {[type]} element       [description]\n * @param  {[type]} target        [description]\n * @param  {[type]} morphParent   [description]\n * @return {Promise} A promise which will be resolved once the animation is complete\n */\nfunction moveAnimation ({\n  namespace,\n  addClasses,\n  removeClasses,\n  element,\n  target,\n  morphParent\n}) {\n  const targetPosition = _getElementPosition(target);\n  const parentPosition = _getElementPosition(morphParent);\n  const top = targetPosition.top - parentPosition.top;\n  const left = targetPosition.left - parentPosition.left;\n  return animation({\n    namespace,\n    element,\n    addClasses,\n    removeClasses,\n    animationName: 'move',\n    onAnimationStart: () => {\n      element.setAttribute('style', `position: absolute; top: ${top}; left: ${left};`);\n    }\n  });\n}\n\n/**\n * Helper function which does the entire animation from start to cleanup\n *\n * @param  {String} namespace       The animation class namespace e.g. 'am'\n * @param  {String[]} addClasses    Classes which will be added once the animation starts\n * @param  {String[]} removeClasses Classes which will be removed once the animation starts\n * @param  {HTMLElement} element    The Element which to animate\n * @param  {HTMLElement} morphParent   [description]\n * @param  {function} [onAnimationStart=(] [description]\n * @return {Promise} A promise which will be resolved once the animation is complete\n */\nfunction animation ({\n  namespace,\n  addClasses,\n  removeClasses,\n  element,\n  animationName,\n  onAnimationStart = () => {}\n}) {\n  return _startAnimation({\n    namespace,\n    element,\n    addClasses,\n    removeClasses,\n    animationName\n  })\n  .then(onAnimationStart)\n  .then(() => waitUntilTransitionEnd(element))\n  .then(() => _removeAnimationClasses({\n    namespace,\n    element,\n    animationName\n  }));\n}\n\nfunction _createLeavePlaceholder (node) {\n  const clone = cloneNode(node);\n  node.insertAdjacentElement('afterend', clone);\n  return clone;\n}\n\n/**\n * Create a clone and place it absolute directly above the given node\n *\n * @param  {HTMLElement} node        The node to clone\n * @param  {HTMLElement} morphParent The parent for the clone\n * @return {HTMLElement} clone\n */\nfunction _createMovePlaceholder (node, morphParent) {\n  const clone = cloneNode(node);\n  const elementPosition = _getElementPosition(node);\n  const parentPosition = _getElementPosition(morphParent);\n  const top = elementPosition.top - parentPosition.top;\n  const left = elementPosition.left - parentPosition.left;\n  clone.setAttribute('style', `position: absolute; top: ${top}; left: ${left};`);\n  document.body.insertAdjacentElement('afterend', clone);\n  return clone;\n}\n\nfunction _startAnimation ({\n  namespace,\n  element,\n  addClasses,\n  removeClasses,\n  animationName = 'enter'\n}) {\n  disableTransitions(element);\n  addClass(element, `${namespace}-${animationName}-prepare`);\n  addClass(element, `${namespace}-${animationName}`);\n  addClass(element, `${namespace}-animate`);\n  return requestAnimationFramePromise().then(() => {\n    removeClass(element, `${namespace}-${animationName}-prepare`);\n    addClass(element, `${namespace}-${animationName}-active`);\n    addClasses.forEach((className) => addClass(element, className));\n    removeClasses.forEach((className) => removeClass(element, className));\n    enableTransitions(element);\n  });\n}\n\nfunction _getElementPosition (node) {\n  const rect = node.getBoundingClientRect();\n  const offset = {\n    top: rect.top + document.body.scrollTop,\n    left: rect.left + document.body.scrollLeft\n  };\n  return offset;\n}\n\nfunction _removeAnimationClasses ({element, animationName, namespace}) {\n  disableTransitions(element);\n  return requestAnimationFramePromise()\n  .then(() => {\n    removeClass(element, `${namespace}-animate`);\n    removeClass(element, `${namespace}-${animationName}`);\n    removeClass(element, `${namespace}-${animationName}-active`);\n    enableTransitions(element);\n  });\n}\n","import {\n  morphAnimation,\n  enterAnimation,\n  leaveAnimation,\n  removeAnimation\n} from './utils/animation';\n\n// Mapping of dom operation to animation\nconst operations = {\n  appendTo: morphAnimation,\n  prependTo: morphAnimation,\n  insertBefore: morphAnimation,\n  insertAfter: morphAnimation,\n  remove: removeAnimation,\n  enter: enterAnimation,\n  leave: leaveAnimation\n};\n\nexport function animorph (element, {\n  namespace = 'am',\n  addClasses = [],\n  removeClasses = [],\n  target,\n  operation = 'appendTo',\n  morphParent = document.body\n}) {\n  let animation = operations[operation];\n  if (!animation) {\n    throw new Error(`Invalid operation '${operation}'`);\n  }\n  if (element instanceof window.HTMLElement === false) {\n    throw new Error('Element is required');\n  }\n  // If we can't use a move animation fallback to an enter animation\n  if (animation === morphAnimation && !element.parentNode) {\n    animation = enterAnimation;\n  }\n  return animation({\n    namespace,\n    addClasses,\n    removeClasses,\n    element,\n    target,\n    operation,\n    morphParent\n  });\n}\n\nexport function appendTo (element, target, options = {}) {\n  return animorph(element, {\n    target,\n    ...options\n  });\n}\n\nexport function prependTo (element, target, options = {}) {\n  return animorph(element, {\n    target,\n    operation: 'prependTo',\n    ...options\n  });\n}\n\nexport function remove (element, options = {}) {\n  return animorph(element, {\n    operation: 'remove',\n    ...options\n  });\n}\n\nexport function insertAfter (element, target, options = {}) {\n  return animorph(element, {\n    target: target,\n    operation: 'insertAfter',\n    ...options\n  });\n}\n\n/**\n * Allows to animate from one set of classes to another\n *\n * @param  {HTMLElement} element        The element to animate\n * @param  {String[]} classNamesBefore  Class names before\n * @param  {String[]} classNamesAfter   Class names after\n * @param  {String} [transitionName]     Transition name (enter or leave)\n * @param  {Object} [options={}]        Animorph options like namespace\n * @return {Promise}                    Promise of the animation\n */\nexport function replaceClasses (element, classNamesBefore, classNamesAfter, transitionName = 'enter', options = {}) {\n  return animorph(element, {\n    addClasses: classNamesAfter,\n    removeClasses: classNamesBefore,\n    operation: transitionName,\n    ...options\n  });\n}\n","import {appendTo, prependTo, remove, insertAfter, replaceClasses} from './vanilla.js';\nimport $ from 'jquery';\n\n$.fn.amAppendTo = function (target, options) {\n  return this.each((i, element) => appendTo(element, $(target)[0], options));\n};\n\n$.fn.amPrependTo = function (target, options) {\n  return this.each((i, element) => prependTo(element, $(target)[0], options));\n};\n\n$.fn.amRemove = function (options) {\n  return this.each((i, element) => remove(element, options));\n};\n\n$.fn.amInsertAfter = function (target, options) {\n  return this.each((i, element) => insertAfter(element, $(target)[0], options));\n};\n\n$.fn.amReplaceClasses = function (classNamesBefore, classNamesAfter, transitionName, options) {\n  return this.each((i, element) => replaceClasses(element, classNamesBefore, classNamesAfter, transitionName, options));\n};\n"],"names":["detachNode","node","parentNode","removeChild","prependNode","targetContainer","firstChild","insertBefore","appendChild","cloneNode","clone","innerHTML","attachNode","target","domOperation","insertAdjacentElement","Error","disableTransitions","style","transition","enableTransitions","waitUntilTransitionEnd","duration","getTransitionDuration","Promise","resolve","getClassNames","element","className","getAttribute","split","toggleClass","force","classNames","idx","indexOf","hasClass","shouldHaveClass","undefined","splice","push","setAttribute","join","removeClass","addClass","stringToMilliSeconds","timeString","timeUnits","parsedTime","exec","parseFloat","window","getComputedStyle","transitionDuration","delay","transitionDelay","requestAnimationFramePromise","requestAnimationFrame","enterAnimation","namespace","addClasses","removeClasses","operation","animation","leaveAnimation","morphAnimation","morphParent","HTMLElement","leavePlaceholder","_createLeavePlaceholder","movePlaceholder","_createMovePlaceholder","all","moveAnimation","then","removeAnimation","options","targetPosition","_getElementPosition","parentPosition","top","left","animationName","onAnimationStart","_startAnimation","_removeAnimationClasses","elementPosition","body","forEach","rect","getBoundingClientRect","offset","document","scrollTop","scrollLeft","animorph","operations","appendTo","prependTo","remove","insertAfter","replaceClasses","classNamesBefore","classNamesAfter","transitionName","setTimeout","$","fn","amAppendTo","this","each","i","amPrependTo","amRemove","amInsertAfter","amReplaceClasses"],"mappings":"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"}